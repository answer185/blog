# 微前端
[[toc]]
## 架构理论
### 背景
企业考虑使用微前端架构的原因主要有3个：
1. 遗留系统的隔离：相引入新的技术栈，但是又不想动老系统。
2. 聚合前端开发：将分散的各个应用聚合，方便使用及管理。
3. 巨石应用的拆分：单页应用不拆分，会越来越庞大，最后变成一个很难维护的应用。启动慢，热更新慢及打包慢。开发体验很差。

微前端架构应运而生，需要达到：
1. 技术栈无关
2. 应用自治：独立运行时及独立开发和部署
3. 单一职责：每个应用会有自己负责区域

### 实现思路
- 路由分发式：通过反向代理，将请求路由到对应的应用上。
- 前端的微服务化：在不同的框架之上设计通信和加载机制。以使一个页面内加载对应的应用。
- 微应用：通过软件工程的试，在部署构建环境中，把多个独立的应用组合成一个单体应用。
- 微件化：开发新的构建系统，把应用打包成独立的chunk代码，然后远程加载。
- 前端容器化：使用iframe来加载
- 应用组件化：使用Web Components技术来构建

微应用、微件及应用组件库与现在的工程体系相差太多，基本上不会使用。主要是路由分发式和前端的微服务化。

### 拆分方式
没有标准的方式，只有一定的考虑角度。
- 按照业务拆分
- 权限
- 更新频率
- 组织机构
- 和后端的微服务保持一致

主要的目标是尽量减少耦合，更接近业务。

### 架构设计点
- 架构模式：基座模式和自组织模式。后者基本不会去考虑。
- 组件与模式库： 抽离出公共的部分
- 应用注册：规划应用的名称、端口、地址等信息，并注册到基座应用中
- 专用构建系统：需要调整输出的格式
- 共享数据结构及操作：比如：主框架应该共享哪些数据，以何种情况存储，数据结构应该是什么样
- 应用通信机制：主流框架主要考虑的是应用之间，但是实际后台系统需要的是页面层级的通信

### 不足
- 项目切换

## 行业方案

### iframe
#### 实现原理
1. 在主应用中管理所有的iframe窗口。每个链接对应一个内部标签页，不重复打开。
2. 每个标签对应一个iframe， 并生成一个唯一的id。
3. 通过postMessage及监听message事件，实现主应用对子应用、子应用对主应用及子应用对子应用的通信。

#### 相关API
1. window.parent: 返回当前窗口的父窗口对象。如果一个窗口没有父窗口,则它的 parent 属性为自身的引用.
2. window.postMessage: 分发一个  MessageEvent 消息。第一个参数为消息数据，第二个参数指定哪些窗口可以接收，*表示不限。可以安全地实现跨源通信。
3. window.addEventListner('messsage', handleMessage, false): 监听广播的message，并做处理

#### 问题及解决
1. 跨域问题：不要通过frameId直接获取相应window的对象，并访问相应的内部变量，如下代码会出现跨域：
```js
window.parent.frames[`iframe_${parentId}`].store.dispatch(actionName, data)
```
解决： 通过postMessage来发送消息，并监听消息来处理：
```js
document.getElementById(`iframe_${parentId}`).contentWindow.postMessage({
  ...params
}, *)
```
2. message事件监听的时机： 对vue来说，在created和onMounted都可以，建议在onMounted。
3. message的解析规则：可以确定了一些固定的参数，如API名称，来确定应该如何处理消息。
4. 打开及关闭标签页面的逻辑处理：修改router.push及router.back, 判断运行环境，并做拦截处理
5. 页面之间的数据通信。

这里假设场景： A页面是一个表单，某个表单项的修改，需要新开一个页面B，保存成功后，需要把数据同步到A页面，数据随A页面一起提交。
以下是一个参考的实现方式：

  - 在A页面点开B页面时，需要把iframe标识带过去
  - 在B页面保存时，先把表单的数据保存在本地，如localStorage中。
  - 发布一个postMessage，更新相应的信息处理标记
  - 间隔500毫秒左右再执行关闭标签页面的操作，否则localstorage里的数据可能没有成功
  - 在A页面中监听信息标记的变化，如果为true时，从按约定从本地获取数据（在多标签页面的后台系统中，已打开的标签页面，不会因为切换了页面而卸载）
  - 处理好数据后，清空本地数据并更新标记。

整个代码结构如下:
```js
// A表单页面打开B页面
this.$router.push({path: '/path/to/B', query: {..., frameId: this.frameId, ...}})

// B页面保存时的，通知主应用
localStorage.setItem('localtDataName', JSON.stringify(rawData))
setTimeout(() => {
  window.parent.postMessage({
    api: 'handleFunc',
    arguments: {
      frameId: 1,
      action: '...',
      ...
    }
  })
  this.$router.back()
}, 500)

// 主应用，根据frameId，发送更新消息，并转发相关参数
document.getElementById(`iframe${frameId}`).contentWindow.postMessage({
  api: 'messageHandleFunc',
  arguments: args
}, '*')

// A页面的监听事件接收
window.addEventListener('message',
  (e) => {
    const params = e.data
    // 当前页面的事件监听条件
    if (params.condition) {
      // 更新标记
      this.$store.dispatch('actionName', { status: true })
    }
  },
  false
)

// store中更新相应的标记
state.status = payload.status

// A页面相关组件绑定及watch
watch: {
  tagStatus(val) {
    if (val) {
      // 处理业务逻辑
      this.handleLogic()
      // 修改标记状态为false
      this.handleStatus()
    }
  },
}
```

以上的流程中，数据可以不在本地保存，直接通过postMessage带

上面的交互是一个复杂的场景，只是作为例子，实际开发中建议通过修改交互，如弹窗来处理。

6. 后台标签页面的管理


7. 页面权限的处理




#### iframe的不足
为什么不用 iframe，这几乎是所有微前端方案第一个会被挑战的问题。但是大部分微前端方案又不约而同放弃了 iframe 方案，自然是有原因的，并不是为了 "炫技" 或者刻意追求 "特立独行"。

如果不考虑体验问题，iframe 几乎是最完美的微前端解决方案了。

iframe 最大的特性就是提供了浏览器原生的硬隔离方案，不论是样式隔离、js 隔离这类问题统统都能被完美解决。但他的最大问题也在于他的隔离性无法被突破，导致应用间上下文无法被共享，随之带来的开发体验、产品体验的问题。

1. url 不同步。浏览器刷新 iframe url 状态丢失、后退前进按钮无法使用。
2. UI 不同步，DOM 结构不共享。想象一下屏幕右下角 1/4 的 iframe 里来一个带遮罩层的弹框，同时我们要求这个弹框要浏览器居中显示，还要浏览器 resize 时自动居中..
3. 全局上下文完全隔离，内存变量不共享。iframe 内外系统的通信、数据同步等需求，主应用的 cookie 要透传到根域名都不同的子应用中实现免登效果。（实际上就是产生了很多页面）
4. 慢。每次子应用进入都是一次浏览器上下文重建、资源重新加载的过程。
5. 网页截屏，iframe 就不被支持
6. 其他： 不容易打印、无法被一些搜索引擎解析、增加http请求及不符合标准网页设计的理念，已经被标准网页设计抛弃。

其中有的问题比较好解决(问题1)，有的问题我们可以睁一只眼闭一只眼(问题4)，但有的问题我们则很难解决(问题3)甚至无法解决(问题2)，而这些无法解决的问题恰恰又会给产品带来非常严重的体验问题， 最终导致我们舍弃了 iframe 方案。

### qiankun

## 后台微前端实践

### 总体设计

### 开发

### 疑难问题及解决
