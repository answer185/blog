# 组件库总结
## 背景
### 解决的问题
系统不同的页面中，经常会有相同或相似的展示内容或某些复杂的业务逻辑。为了避免重复开发，需要对其进行封装，方便调用。同时降低业务开发的上手难度。

### 实现方式
#### 方式一、共享目录
这是最简单的实现方式，在项目中独立一个目录，将需要抽离的组件放在该目录即可。
对于一个未拆分的应用，该方式实现起来最容易，组件的调试与业务无缝结合。
不足：容易形成巨石应用
#### 方式二、子库
随着应用的演进，需要对应用进行拆分。不管是何种的拆分方案，组件库都会是一个独立的项目。
最简单的方式就是单独成一个仓库，在嵌入到各业务项目中，达到一处更新，多个项目使用的效果。
组件的预览及调试通常还是和业务结合。
不足：
  1. 业务迭代多的时候容易冲突
  2. 代码冗余在业务代码中，可能会有误改误删的情况
  3. 只有启动某个业务系统才可以预览
  4. 组件的使用信息，只能去查看源码
#### 方式三、package包
当有专门的人维护时，公共组件的代码通常会做成一个包，业务端只需要提出需求，由相应的人开发，之后更新包的版本即可。
不足：
  - 如果没有合适的流程保障组件的稳定性，其实比方式二更不方便。
  - 业务层开发的同学经常会在等待的状态
  - 开发组件时，还是需要依赖业务项目，并未脱离
#### 方式四、文档系统
开源项目中有像vitepress, dumi这样可以解析markdown及vue\react组件代码的系统。整合此类系统后，可以达到可以视化预览组件、书写组件的props等信息。

该方式基本可以满足日常的开发需求。可以先书写出相应的props及demo代码供业务层调用。
业务开发同学，可以通过部署的文档系统，随时查看相关的组件信息。
#### 方式五、标准化
像element-plus\ant-design这样的库，基本上把本地开发、构建、组件封装、组件相关的utils、directives、hooks等都做成标准，以子包的方式对外暴露。方便创建新的组件库。

## 技术设计的关注点
### 框架的构建
#### 方案一、自己搭建
如果从零到一，一般公司是逐步做到方案四，根据当时的技术选型，最终的效果差别会很大。耗费的时间和资源也会比较大。
优点在于自己完全可控且逐步演进，也不需要着急。
不足在于：任意优秀的新特性，都需要自己动手增加。有些成本较大的特性，可能需要放弃。

#### 方案二、改造成熟的组件库框架
另外一种方案是直接使用成熟的组件库框架改造。
优点在于：
  1. 优秀的组件库框架，基本上也代表着当前的最佳实践，不需要费时间和资源去考虑前端生态各种库及插件的组合方式。
  2. 组件库框架的技术难点及新的特性，组件库框架的维护团队会演进，不需要耗费资源。
不足在于：
  1. 需要理解相关库的设计。
  2. 需要定期跟进迭代：通常组件库团队在引入新的技术后，不会考虑向下兼容

### 组件的技术设计
#### 业务场景的抽象
通常每个组件都于多个业务场景的聚合，像表格、表单这样的组件，更是涉及到系统的所有列表及表单页面。
组件的技术设计需要考虑多种场景，而不是业务开发时的专一场景。
不同的场景会直接影响到组件的props、事件及插槽等设计。

#### 组件的层级带来通信的复杂度
为了增强复用性，组件库拆分的颗粒度都会比较细。这是为了方便后续的维护及复用。
这样也会带来一样的问题，组件的层级会比较深。特别是有页面级配置组件时。数据的传递会的5层。
在开发时，通信的复杂度也会增加。

目前后台组件库的数据传递用的是最麻烦的方式，通过props，一级级往下传。

#### 组件的高度封装带来配置的复杂度和调试复杂度
比如列表页面组件，这样的组件会包含当前系统组件库的所有组件。
在配置的时候如果没有一定的规范，会写出不好理解的内容。
又因为高度封装，调试的时候会无从下手。

需要一个标准的规范来限制。

#### 组件是否过度设计
比如列表页面组件，如果要考虑扩展性，那需要把底层的所有slot暴露到外层。
但是这样组件的复杂度会更进一步。

### 组件的开发和调试
一般我们都会有一个初始化组件的命令，初始化组件相关的文件，使开发的同学可以更专注在业务逻辑上。

初始化后的组件可以直接在文档中运行，我们一般参照以下顺序开发一个组件：
1. 首先是书写文档: 在文档上书写组件的使用场景及技术设计，方便梳理思路及与业务开发的同学并行工作。
2. 组件的逻辑开发: 使用文档系统上的展示来调试
3. 组件使用的最佳实践demo书写：这层是业务实际使用的场景调试 

## ElementPlus的实现原理
最近一次的开发是基于ElementPlus 2.X改造，以封装公司后台的组件库

### 组件封装
在业务开发中，简单的组件封装，通常只有一个.vue文件。在element-plus中，除了组件层逻辑的封装，还考虑了：
- 单元测试
- props的分离
- css的分离
- 组件的导出
以affix为例，标准的目录结构如下：
```
__tests__
  affix.spec.tsx // 单元测试
src
  affix.ts // props的标准化定义
  affix.vue // 组件逻辑
style
  css.ts // 从them-chalk中导入相应的css
  index.ts // 从them-chalk中导入相应的css
index.ts   // 导出该组件
```

### 组件包的封装
拆分多个子包，通过element-plus，统一导出。
组件相关的子包有：
- @element-plus/components: 所有的组件
- @element-plus/constants: 所有定义的常量
- @element-plus/hooks: 组件公共的hooks
- @element-plus/locale: 组件的语言包
- @element-plus/test-utils: 单无测试的辅助工具函数
- @element-plus/theme-chalk: 组件库的css
- @element-plus/tokens: 组件相关的typescript 类型
- @element-plus/utils: 组件相关的辅助函数

### 构建
Element-plus 2.X已经封装成相关的子包
- @element-plus/build
- @element-plus/build-constants
- @element-plus/build-utils
底层是基于gulp、esbuild及rollup实现
gulp用与管理相关的任务，控制并行和串行。
esbuild及rollup处理构建与打包

### 文档系统
基于vitepress实现，自定义的主题，需要注意的规则有：
1. vitepress配置：在.vitepress/config目录下
2. 组件左侧的菜单配置在：.vitepress/crowdin/en-US/pages/component.json下
3. vite.config.ts里关联了element-plus的组件目录，所以可以在文档系统中直接导入


## 基于ElementPlus的改造
根据业务需要，主要做了以下的内容：
1. 删除不必要的代码
2. 修改导出饭名称
3. 构建时生成的规则修改
4. 文档系统的外观修改，如菜单、说明文档等
5. play系统：替换成公司内部的base模板，并增加基于包及组件库代码调试的开关（这里的play系统类似ant-design-pro，是对组件库及业务场景结合运用时最佳实践的阐释）
6. 组件初始化工具的增加：通过一定的命令行提示，初始化相关的组件
7. 与公司的jenkins对接，输出组件库包、文档系统及play系统。
